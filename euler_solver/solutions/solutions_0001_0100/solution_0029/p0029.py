#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Project Euler Problem 29: Distinct Powers.

Problem Statement:
    Consider all integer combinations of a^b for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:

        2^2=4, 2^3=8, 2^4=16, 2^5=32
        3^2=9, 3^3=27, 3^4=81, 3^5=243
        4^2=16, 4^3=64, 4^4=256, 4^5=1024
        5^2=25, 5^3=125, 5^4=625, 5^5=3125

    If they are then placed in numerical order, with any repeats removed, we get the
    following sequence of 15 distinct terms:

        4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125.

    How many distinct terms are in the sequence generated by a^b for 2 ≤ a ≤ 100
    and 2 ≤ b ≤ 100?

Solution Approach:
    Generation of all powers a^b for the given ranges is straightforward. Use a set
    to store and eliminate duplicates efficiently. The main challenge is to do this
    within reasonable time by avoiding recalculation and exploiting properties of
    powers if needed. Time complexity is O(N^2) with N=99 here, which is acceptable.

Answer: 9183
URL: https://projecteuler.net/problem=29
"""
from __future__ import annotations

from typing import Any

import pyprimesieve as pps

from euler_solver.framework import evaluate, logger, register_solution
from euler_solver.lib_primes import prime_factorization

euler_problem: int = 29
framework_version: str = '0.2.1'
test_cases: list[dict[str, Any]] = [
    {'category': 'dev', 'input': {'a_min': 2, 'a_max': 5, 'b_min': 2, 'b_max': 5}, 'answer': 15},
    {'category': 'main', 'input': {'a_min': 2, 'a_max': 100, 'b_min': 2, 'b_max': 100}, 'answer': 9183},
    {'category': 'extra', 'input': {'a_min': 2, 'a_max': 1000, 'b_min': 2, 'b_max': 1000}, 'answer': 977358},
]


@register_solution(euler_problem=euler_problem, max_test_case_index=None)
def solve_distinct_powers_p0029_s0(*, a_min: int, a_max: int, b_min: int, b_max: int) -> int:
    if min(a_max, b_max) > 100:
        unique_powers = set()
        for a in range(a_min, a_max + 1):
            prime_factors = prime_factorization(a)
            for b in range(b_min, b_max + 1):
                signature = tuple(((prime, power * b) for prime, power in prime_factors))
                unique_powers.add(signature)
        return len(unique_powers)
    else:
        return len({a ** b for a in range(a_min, a_max + 1) for b in range(a_min, a_max + 1)})


@register_solution(euler_problem=euler_problem, max_test_case_index=None)
def solve_distinct_powers_p0029_s1_pps(*, a_min: int, a_max: int, b_min: int, b_max: int) -> int:
    if min(a_max, b_max) > 100:
        unique_powers = set()
        for a in range(a_min, a_max + 1):
            prime_factors = pps.factorize(a)
            for b in range(b_min, b_max + 1):
                signature = tuple(((prime, power * b) for prime, power in prime_factors))
                unique_powers.add(signature)
        return len(unique_powers)
    else:
        return len({a ** b for a in range(a_min, a_max + 1) for b in range(a_min, a_max + 1)})


if __name__ == '__main__':
    logger.setLevel('ERROR')
    raise SystemExit(evaluate(euler_problem=euler_problem, time_out_in_seconds=300))
