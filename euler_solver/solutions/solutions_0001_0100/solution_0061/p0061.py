#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Project Euler Problem 61: Cyclical Figurate Numbers.

Problem Statement:
    Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all
    figurate (polygonal) numbers and are generated by the following formulae:

    Triangle: P_3,n = n(n+1)/2        1, 3, 6, 10, 15, ...
    Square:   P_4,n = n^2             1, 4, 9, 16, 25, ...
    Pentagonal: P_5,n = n(3n-1)/2     1, 5, 12, 22, 35, ...
    Hexagonal:  P_6,n = n(2n-1)       1, 6, 15, 28, 45, ...
    Heptagonal: P_7,n = n(5n-3)/2     1, 7, 18, 34, 55, ...
    Octagonal:  P_8,n = n(3n-2)       1, 8, 21, 40, 65, ...

    The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting
    properties.

    1. The set is cyclic, in that the last two digits of each number is the first two digits
       of the next number (including the last number with the first).
    2. Each polygonal type: triangle (P_3,127=8128), square (P_4,91=8281), and pentagonal
       (P_5,44=2882), is represented by a different number in the set.
    3. This is the only set of 4-digit numbers with this property.

    Find the sum of the only ordered set of six cyclic 4-digit numbers for which each
    polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is
    represented by a different number in the set.

Solution Approach:
    Use combinatorial search with backtracking over sets of 4-digit polygonal numbers.
    Generate all 4-digit polygonal numbers for each type. Then search cyclic sequences of
    length six covering all polygonal types once. Use last two digits to first two digits
    matching property as a graph linking condition. Efficient pruning and caching will be
    important. The problem is a finite search with manageable complexity.

Answer: [1, 28684]
URL: https://projecteuler.net/problem=61
"""
from __future__ import annotations

from enum import Enum
from functools import wraps
from math import ceil, floor, sqrt
from typing import Any, Callable, Generator

from euler_solver.framework import evaluate, logger, register_solution, show_solution

euler_problem: int = 61
framework_version: str = '0.2.1'
test_cases: list[dict[str, Any]] = [
    {'category': 'dev', 'input': {'length': 2}, 'answer': [1, 8181]},
    {'category': 'dev', 'input': {'length': 3}, 'answer': [1, 19291]},
    {'category': 'dev', 'input': {'length': 4}, 'answer': [2, [12524, 16160]]},
    {'category': 'dev', 'input': {'length': 5}, 'answer': [5, [12019, 15857, 18685, 19493, 26058]]},
    {'category': 'main', 'input': {'length': 6}, 'answer': [1, 28684]},
]


def n_is_positive_integer[T](func: Callable[[int], T]) -> Callable[[int], T]:
    @wraps(func)
    def wrapper(n: int) -> T:
        if isinstance(n, int) and n > 0:
            return func(n)
        else:
            raise ValueError(f"'n' must be a positive integer, got {n}")

    return wrapper


@n_is_positive_integer
def nth_triangle_number(n: int) -> int:
    return (n * (n + 1)) // 2


@n_is_positive_integer
def is_triangle_number(n: int) -> bool:
    return ((-1 + sqrt(1 + 8 * n)) / 2).is_integer()


@n_is_positive_integer
def closest_triangle_number(n: int) -> tuple[float, int, int]:
    return (i := (-1 + sqrt(1 + 8 * n)) / 2), nth_triangle_number(floor(i)), nth_triangle_number(ceil(i))


@n_is_positive_integer
def nth_square_number(n: int) -> int:
    return n ** 2


@n_is_positive_integer
def is_square_number(n: int) -> bool:
    return sqrt(n).is_integer()


@n_is_positive_integer
def closest_square_number(n: int) -> tuple[float, int, int]:
    return (i := sqrt(n)), nth_square_number(floor(i)), nth_square_number(ceil(i))


@n_is_positive_integer
def nth_pentagonal_number(n: int) -> int:
    return (n * (3 * n - 1)) // 2


@n_is_positive_integer
def is_pentagonal_number(n: int) -> bool:
    return ((1 + sqrt(1 + 24 * n)) / 6).is_integer()


@n_is_positive_integer
def closest_pentagonal_number(n: int) -> tuple[float, int, int]:
    return (i := (1 + sqrt(1 + 24 * n)) / 6), nth_pentagonal_number(floor(i)), nth_pentagonal_number(ceil(i))


@n_is_positive_integer
def nth_hexagonal_number(n: int) -> int:
    return n * (2 * n - 1)


@n_is_positive_integer
def is_hexagonal_number(n: int) -> bool:
    return ((1 + sqrt(1 + 8 * n)) / 4).is_integer()


@n_is_positive_integer
def closest_hexagonal_number(n: int) -> tuple[float, int, int]:
    return (i := (1 + sqrt(1 + 8 * n)) / 4), nth_hexagonal_number(floor(i)), nth_hexagonal_number(ceil(i))


@n_is_positive_integer
def nth_heptagonal_number(n: int) -> int:
    return (n * (5 * n - 3)) // 2


@n_is_positive_integer
def is_heptagonal_number(n: int) -> bool:
    return ((3 + sqrt(9 + 40 * n)) / 10).is_integer()


@n_is_positive_integer
def closest_heptagonal_number(n: int) -> tuple[float, int, int]:
    return (i := (3 + sqrt(9 + 40 * n)) / 10), nth_heptagonal_number(floor(i)), nth_heptagonal_number(ceil(i))


@n_is_positive_integer
def nth_octagonal_number(n: int) -> int:
    return n * (3 * n - 2)


@n_is_positive_integer
def is_octagonal_number(n: int) -> bool:
    return ((2 + sqrt(4 + 12 * n)) / 6).is_integer()


@n_is_positive_integer
def closest_octagonal_number(n: int) -> tuple[float, int, int]:
    return (i := (2 + sqrt(4 + 12 * n)) / 6), nth_octagonal_number(floor(i)), nth_octagonal_number(ceil(i))


class FigurateNumber(Enum):
    """Enumeration of all figurate (polygonal) numbers.

    Each enum value represents a specific polygonal number type,
    with the value indicating the number of sides in the polygon.
    For example, TRIANGLE=3 for 3-sided polygons, SQUARE=4 for 4-sided, etc.

    This enum provides a type-safe way to reference different figurate number types
    and is used as keys in the function mapping dictionaries (p_funcs, v_funcs, c_funcs).
    """
    TRIANGLE = 3
    SQUARE = 4
    PENTAGONAL = 5
    HEXAGONAL = 6
    HEPTAGONAL = 7
    OCTAGONAL = 8

    def __str__(self) -> str:
        """Return the enum member as a title-cased string."""
        return self.name.title()


# dictionary mapping figurate number types to their nth calculation functions
p_funcs: dict[FigurateNumber, Callable[[int], int]] = {
    FigurateNumber.TRIANGLE: nth_triangle_number,
    FigurateNumber.SQUARE: nth_square_number,
    FigurateNumber.PENTAGONAL: nth_pentagonal_number,
    FigurateNumber.HEXAGONAL: nth_hexagonal_number,
    FigurateNumber.HEPTAGONAL: nth_heptagonal_number,
    FigurateNumber.OCTAGONAL: nth_octagonal_number,
}
# dictionary mapping figurate number types to their validation functions
v_funcs: dict[FigurateNumber, Callable[[int], bool]] = {
    FigurateNumber.TRIANGLE: is_triangle_number,
    FigurateNumber.SQUARE: is_square_number,
    FigurateNumber.PENTAGONAL: is_pentagonal_number,
    FigurateNumber.HEXAGONAL: is_hexagonal_number,
    FigurateNumber.HEPTAGONAL: is_heptagonal_number,
    FigurateNumber.OCTAGONAL: is_octagonal_number,
}
# dictionary mapping figurate number types to their closest-finding functions
c_funcs: dict[FigurateNumber, Callable[[int], tuple[float, int, int]]] = {
    FigurateNumber.TRIANGLE: closest_triangle_number,
    FigurateNumber.SQUARE: closest_square_number,
    FigurateNumber.PENTAGONAL: closest_pentagonal_number,
    FigurateNumber.HEXAGONAL: closest_hexagonal_number,
    FigurateNumber.HEPTAGONAL: closest_heptagonal_number,
    FigurateNumber.OCTAGONAL: closest_octagonal_number,
}


def p_gen(p_num: FigurateNumber, min_value: int = 0, max_value: int = 2 ** 32) -> Generator[int, None, None]:
    p_func: Callable[[int], int] = p_funcs[p_num]
    c_func: Callable[[int], tuple[float, int, int]] = c_funcs[p_num]
    start_num: int = floor(c_func(min_value)[0])
    stop_num: int = ceil(c_func(max_value)[0]) + 1
    for i in range(start_num, stop_num):
        if min_value <= (p := p_func(i)) <= max_value:
            yield p


@register_solution(euler_problem=euler_problem, max_test_case_index=None)
def solve_cyclical_figurate_numbers_p0061_s0(*, length: int) -> list:
    min_value: int = 10 ** 3
    max_value: int = 10 ** 4 - 1
    generator_funcs: dict[FigurateNumber, Generator[int, None, None]] = {
        (p_num := FigurateNumber(n)): p_gen(p_num=FigurateNumber(p_num), min_value=min_value, max_value=max_value) for n
        in range(3, length + 3)}
    p_numbers: dict[FigurateNumber, set[int]] = {p_num: set(gen) for p_num, gen in generator_funcs.items()}
    number_to_next_graph: dict[int, list[int]] = {n: list() for vals in p_numbers.values() for n in vals}
    for next_number in number_to_next_graph.keys():
        first_two_digits = next_number // 100
        for previous_number, successor_list in number_to_next_graph.items():
            if first_two_digits == previous_number % 100:
                successor_list.append(next_number)
    cyclic_paths: set[tuple[int, ...]] = set()
    for start_num in (k for k, v in number_to_next_graph.items() if v):
        for path in find_cyclic_paths(start_num, start_num, [start_num], {start_num}, number_to_next_graph, length):
            cyclic_paths.add(tuple(sorted(path)))
    valid_cyclic_paths: list[tuple[int, ...]] = sorted(
            (path for path in cyclic_paths if verify_polygon_types(path, p_numbers)), key=sum)
    if show_solution():
        from pprint import pprint
        for valid_cyclic_path in valid_cyclic_paths:
            figurates = {n: tuple((str(k) for k, v in p_numbers.items() if n in v)) for n in valid_cyclic_path}
            print(f'length={length!r} {figurates}')
            pprint(figurates)
    return [(len_paths := len(valid_cyclic_paths)),
            sum(valid_cyclic_paths[0]) if len_paths == 1 else [sum(path) for path in valid_cyclic_paths]]


def find_cyclic_paths(start: int, current: int, path: list[int], visited: set[int],
                      number_mapping: dict[int, list[int]], target_length: int) -> list[tuple[int, ...]]:
    if len(path) == target_length:
        if current % 100 == start // 100:
            return [tuple(path[:])]
        return []
    result: list[tuple[int, ...]] = []
    for next_num in number_mapping.get(current, []):
        if next_num not in visited:
            path.append(next_num)
            visited.add(next_num)
            result.extend(find_cyclic_paths(start, next_num, path, visited, number_mapping, target_length))
            path.pop()
            visited.remove(next_num)
    return [tuple(r) for r in result]


def verify_polygon_types(chain: tuple[int, ...], p_numbers: dict[FigurateNumber, set[int]]) -> bool:
    figurate_in_chain: dict[FigurateNumber, list[int]] = {k: [n for n in chain if n in v] for k, v in p_numbers.items()}
    if any((len(n) == 0 for n in figurate_in_chain.values())):
        return False
    figurate_in_chain_rev: dict[int, list[FigurateNumber]] = {}
    for k_f, v_f in figurate_in_chain.items():
        for n_f in v_f:
            figurate_in_chain_rev.setdefault(n_f, []).append(k_f)
    for k_r, v_r in figurate_in_chain_rev.items():
        if len(v_r) > 1:
            if all((len(f) == 1 for n_r in v_r if (f := figurate_in_chain[n_r]))):
                return False
    return True


if __name__ == '__main__':
    logger.setLevel('ERROR')
    raise SystemExit(evaluate(euler_problem=euler_problem, time_out_in_seconds=300))
